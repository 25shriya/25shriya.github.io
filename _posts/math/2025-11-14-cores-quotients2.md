---
layout: post
title:  "Cores and Quotients of Integer Partitions - Part 2"
---

{%- include mathjax.html -%}

This article uses the previously stated bijection between $p$-cores $\lambda_{(p)}$ and $p$-quotients $\lambda^{(p)} = (\lambda_0, \ldots, \lambda_{p-1})$ and their corresponding unique partition $\lambda$, along with the equation $\mid \lambda \mid = \mid \lambda_{(p)} \mid + p^*(\mid \lambda_0 \mid + \ldots + \mid \lambda_{p-1} \mid)$. The case when $p=2$ is used to generate random integer partitions, and the following equation is obtained:
{% raw %}
\begin{equation}
\label{eq:equivalence}
\mid \lambda \mid = \mid \lambda_{(2)} \mid + 2^*(\mid \lambda_0 \mid + \mid \lambda_{1} \mid)
\end{equation}
{% endraw %}

------------

## $2$-Cores and $2$-Quotients of an Integer Partition

A $\textit{triangular number}$ is a number $t_k$ which can be written as a sum $t_k = 1 + 2 + \ldots + n$ for some positive integer $n < t_k$. A $\textit{staircase partition}$ is a partition of the form $(n, n - 1, \ldots, 2, 1)$ for some positive integer $n$. We now claim that every $2$-core (say $\lambda_{(2)} = (a_1, a_2, \ldots, a_m)$) is a staircase partition. It can be proved by the following case analysis:

1. If there exists an $i$ such that $a_i - a_{i-1} > 1$, then the last two boxes corresponding to $a_i$, i.e., a $2$-hook in the Young diagram of $\lambda_{(2)}$ can be removed from it, a contradiction.

2. Otherwise, if there exists an $1 \leq i < m$ and a $1 \leq k \leq m - i$ such that $a_i = a_{i+1} = \ldots = a_{i+k}$, then we can remove the last two boxes corresponding to $a_i$, i.e., a $2$-hook. This is once again a contradiction.

Now, we state that the probability of obtaining a $2$-core (for a partition of $n$) of size $t_k \leq n$ where $t_k$ is a triangular number is the following:
<div style="text-align: center;">
$$
P(\mid \lambda_{(2)} \mid = t_k) = 
\begin{cases}
\sum_{i+j = \frac{n=t_k}{2}} \frac{p(i)p(j)}{p(n)}, & \text{ if } n - t_k \text{ is even, and} \\
0, & \text{ if } n - t_k \text{ is odd}
\end{cases}
$$
</div>

Here, $p(n)$ is the number of partitions for a positive integer $n$. The above statement is proved using the following case split:

1. $n - t_k$ can never be odd from Equation \ref{eq:equivalence}. Thus, the probability of obtaining a $2$-core of size $t_k$ in this case is $0$.

2. If $n - t_k$ is even, the possibilites of sizes of $2$- quotients are $(0, \frac{n-t_k}{2}), (1, \frac{n-t_k}{2} - 1), \ldots (\frac{n-t_k}{2}, 0)$. So, the probability of obtaining a $2$-core of size $t_k$ in this case is $\sum_{i+j = \frac{n=t_k}{2}} \frac{p(i)p(j)}{p(n)}$.

The probability of obtaining a $2$-quotient of size $(i, \frac{n-t_k}{2} - i)$ is:
<div style="text-align: center;">
$$
P(\mid \lambda_{0} \mid = i) = 
 \frac{p(i)p(\frac{n-t_k}{2} - i)}{\sum_{j=0}^{\frac{n=t_k}{2}}p(j)p(\frac{n-t_k}{2} - j)}.
$$
</div>

------------

## Generating a Random Partition Using $2$-Cores and $2$-Quotients

A random partition $\lambda$ can be generated by randomly choosing sizes of $2$-cores and and $2$-quotients from their probabilities. A triangular number is chosen randomly and the corresponding staircase partition is its $2$-core. The sizes of $2$-quotients is picked randomly and the function is called recursively to get its $2$-quotients. Shown below is the flowchart of this algorithm:

<figure style="text-align: center;">
  <img src="{{ '/images/random-partition.png' | relative_url }}" alt="description" width="100%">
  <figcaption>Figure 1: Generating a Random Partition using $2$-Core and $2$-Quotient Probabilities.</figcaption>
</figure>

The SageMath script for the latter is:
```python
def triangle(n):
    k = 1
    i = 1
    l = []
    while(k<=n):
        k = (i*(i+1))/2
        i += 1
        if k<n:
            l.append(k)
    return l


def random_partition(n):
    if n == 0: # base cases
        return Partition([])
    elif n == 1:
        return Partition([1])
    
    else:
        def core_prob(n,k):
            # generate core probabilities
            if (n - k)%2 == 1: 
                return 0
            else:
                m = ((n - k)/2)
                return sum([(number_of_partitions(i)*
                             number_of_partitions(m-i))/
                             number_of_partitions(n) 
                             for i in range(m)])

        from numpy.random import choice
        core_prob_array = [core_prob(n, a) for a in triangle(n)]
        #  choose random 2-core
        core_integer = choice(triangle(n), p=core_prob_array) 
        m = (n-core_integer)/2

        def generate_quotient(n,k):
            # Generate quotient probabilities
            m = (n - k)/2
            sum_prob = sum([number_of_partitions(i)*
                            number_of_partitions(m-i) 
                            for i in range(m)])
            prob = [(number_of_partitions(i)*
                     number_of_partitions(m-i)/sum_prob) 
                     for i in range(m)]
            return prob

        quotient_one = choice(range(m), 
                        generate_quotient(n,core_integer)) 
                        # choose random 2-quotient
        quotient_two = m-quotient_one
        
        i = triangle(n).index(core_integer)
        two_core = Partition(core=range(1,index), quotient=())
        lambda_one = random_partition(quotient_one)
        lambda_two = random_partition(quotient_two)
        
        return Partition(core=two_core, 
                         quotient=(lambda_one, lambda_two))
```

The efficiency of the above code is comparable to the one implemented currently for random integer partitions generation in SageMath. 



This work was done as part of my undergraduate dissertation under the supervision of [Dr Amritanshu Prasad.](https://www.imsc.res.in/~amri/), who was the author of the above algorithm. The SageMath code was scripted by me.
